// --- START OF FILE ui_online_test.js ---
// --- START MODIFIED ---
import { currentOnlineTestState, setCurrentOnlineTestState, currentSubject, currentUser, data, setData, activeCourseId, userCourseProgressMap, globalCourseDataMap, updateUserCourseProgress } from './state.js';
import { displayContent, clearContent, setActiveSidebarLink } from './ui_core.js';
import { showLoading, hideLoading, escapeHtml, getFormattedDate, renderMathIn as utilsRenderMathIn } from './utils.js'; 
import { saveUserData, markChapterStudiedInCourse, saveUserCourseProgress, updateUserCredits } from './firebase_firestore.js'; // Added updateUserCredits
import { showTestGenerationDashboard } from './ui_test_generation.js';
import { showExamsDashboard } from './ui_exams_dashboard.js';
import { SKIP_EXAM_PASSING_PERCENT, PASSING_GRADE_PERCENT, MAX_BONUS_FROM_TESTGEN, MAX_TOTAL_TESTGEN_BONUS_CAP_FOR_COURSE, COURSE_BASE_PATH, SUBJECT_RESOURCE_FOLDER, DEFAULT_COURSE_TEXT_PROBLEMS_FILENAME, DEFAULT_COURSE_TEXT_MCQ_FILENAME, DEFAULT_COURSE_LECTURE_MCQ_FILENAME, DEFAULT_COURSE_LECTURE_PROBLEMS_FILENAME } from './config.js';
// --- MODIFIED: Import generateExamFeedbackPdfHtml ---
import { generateExamFeedbackPdfHtml, generateAndDownloadPdfWithMathJax } from './ui_pdf_generation.js';
import { storeExamResult, getExamDetails, showExamReviewUI, showIssueReportingModal, submitIssueReport, deleteCompletedExamV2 as deleteTestgenExam } from './exam_storage.js'; // Renamed deleteCompletedExamV2
import { generateLatexToolbar } from './ui_latex_toolbar.js';
import { calculateTotalMark, getLetterGrade } from './course_logic.js';
// --- END MODIFIED ---

// --- Add global listener variable ---
let onlineTestKeyListener = null;

export function launchOnlineTestUI() {
    if (onlineTestKeyListener) {
        document.removeEventListener('keydown', onlineTestKeyListener);
        onlineTestKeyListener = null;
        console.log("[Launch Test UI] Removed previous online test key listener.");
    }

    clearContent();
    const testArea = document.getElementById('online-test-area');
    
    if (!currentOnlineTestState) {
        console.error("launchOnlineTestUI Error: Online test state missing.");
        displayContent("<p class='text-red-500 p-4'>Error: Could not start the test. Test state missing.</p>", 'content');
        return;
    }
    if (!testArea) {
        console.error("launchOnlineTestUI Error: Test area element (#online-test-area) not found.");
        alert("Critical Error: Test UI container is missing from the page. Cannot launch test.");
        return;
    }

    testArea.classList.remove('hidden');

    const totalQuestions = currentOnlineTestState.questions.length;
    const durationMinutes = currentOnlineTestState.durationMinutes;
    if (!durationMinutes || durationMinutes <= 0) {
         console.error("Invalid duration in test state:", durationMinutes);
         currentOnlineTestState.durationMinutes = 60; // Fallback
    }
    const durationMillis = currentOnlineTestState.durationMinutes * 60 * 1000;
    currentOnlineTestState.endTime = currentOnlineTestState.startTime + durationMillis;
    currentOnlineTestState.status = 'active';

    let displayTitle = currentOnlineTestState.examId;
    if (currentOnlineTestState.courseContext?.isSkipExam) { /* ... existing title logic ... */ }
    if (currentOnlineTestState.courseContext?.activityType) {
        const type = currentOnlineTestState.courseContext.activityType.replace(/_/g, ' ');
        const idPart = currentOnlineTestState.courseContext.activityId || '';
        displayTitle = `${type.charAt(0).toUpperCase() + type.slice(1)} ${idPart}`;
        if(currentOnlineTestState.courseContext.courseId) {
            const courseName = globalCourseDataMap.get(currentOnlineTestState.courseContext.courseId)?.name || '';
            if(courseName) displayTitle += ` (${courseName})`;
        }
    } else if (currentOnlineTestState.subjectId) {
         const subjectName = window.data?.subjects?.[currentOnlineTestState.subjectId]?.name || 'TestGen';
         displayTitle = `${subjectName} Test`;
    }


    testArea.innerHTML =  `
    <div class="fixed top-0 left-0 right-0 bg-white dark:bg-gray-800 p-3 shadow z-40 border-b dark:border-gray-700">
        <div class="container mx-auto flex justify-between items-center">
            <span class="text-lg font-semibold text-primary-600 dark:text-primary-400 truncate max-w-[calc(100% - 250px)]" title="${escapeHtml(currentOnlineTestState.examId)}">
                ${escapeHtml(displayTitle)}
            </span>
            <div class="flex items-center space-x-4">
                <button id="force-submit-btn" onclick="window.confirmForceSubmit()" class="btn-danger-small hidden flex-shrink-0">Submit Now</button>
                <div id="timer" class="text-lg font-mono px-3 py-1 bg-gray-200 dark:bg-gray-700 rounded flex-shrink-0">--:--:--</div>
            </div>
        </div>
    </div>
    <div id="question-container" class="pt-20 pb-24 container mx-auto px-4">
        <div class="text-center p-8"><div class="loader animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary-500 mx-auto"></div><p class="mt-4">Loading first question...</p></div>
    </div>
    <div class="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 p-3 shadow-up z-40 border-t dark:border-gray-700">
         <div class="container mx-auto flex justify-between items-center">
             <button id="prev-btn" onclick="window.navigateQuestion(-1)" class="btn-secondary" disabled>
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" /></svg>
                 Previous
             </button>
            <span id="question-counter" class="text-sm text-gray-600 dark:text-gray-400">Question 1 / ${totalQuestions}</span>
             <button id="next-btn" onclick="window.navigateQuestion(1)" class="btn-primary">
                 Next
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 ml-1"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3" /></svg>
             </button>
             <button id="submit-btn" onclick="window.confirmSubmitOnlineTest()" class="btn-success hidden">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5" /></svg>
                 Submit Test
             </button>
        </div>
    </div>
    `;

    onlineTestKeyListener = (event) => {
        if (document.activeElement && (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'INPUT')) {
            // Don't navigate if user is typing in an input/textarea
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                // Allow default behavior for text navigation
                return;
            }
        }

        if (event.key === 'ArrowLeft') {
            event.preventDefault(); // Prevent browser back navigation
            const prevBtn = document.getElementById('prev-btn');
            if (prevBtn && !prevBtn.disabled) {
                window.navigateQuestion(-1);
            }
        } else if (event.key === 'ArrowRight') {
            event.preventDefault(); // Prevent browser forward navigation
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('submit-btn');
            if (nextBtn && !nextBtn.classList.contains('hidden') && !nextBtn.disabled) {
                window.navigateQuestion(1);
            } else if (submitBtn && !submitBtn.classList.contains('hidden') && !submitBtn.disabled) {
                // If on last question, ArrowRight could potentially open submit confirmation
                // For now, it does nothing to avoid accidental submission.
                // window.confirmSubmitOnlineTest(); // Uncomment to make ArrowRight submit on last Q
            }
        }
    };
    document.addEventListener('keydown', onlineTestKeyListener);
    console.log("[Launch Test UI] Added online test key listener.");

    startTimer();
    displayCurrentQuestion();
}

export function startTimer() {
    const timerElement = document.getElementById('timer');
    if (!timerElement) { console.warn("startTimer: Timer element (#timer) not found."); return; }
    if (!currentOnlineTestState) { console.warn("startTimer: currentOnlineTestState is null."); timerElement.textContent = "Error"; return; }
    if (currentOnlineTestState.timerInterval) { clearInterval(currentOnlineTestState.timerInterval); }
    function updateTimerDisplay() {
        if (!currentOnlineTestState || !currentOnlineTestState.endTime || currentOnlineTestState.status === 'submitting' || currentOnlineTestState.status === 'completed') {
             if(currentOnlineTestState?.timerInterval) clearInterval(currentOnlineTestState.timerInterval);
             currentOnlineTestState.timerInterval = null;
             if(timerElement) timerElement.textContent = "00:00:00";
             return;
        }
        const now = Date.now(); const remaining = currentOnlineTestState.endTime - now;
        if (remaining <= 0) {
            clearInterval(currentOnlineTestState.timerInterval);
            currentOnlineTestState.timerInterval = null;
            if (timerElement) { timerElement.textContent = "00:00:00"; timerElement.classList.add('text-red-500'); }
            if (currentOnlineTestState.status !== 'submitting' && currentOnlineTestState.status !== 'completed') {
                 currentOnlineTestState.status = 'submitting';
                 alert("Time's up! Submitting test.");
                 submitOnlineTest();
            }
        } else {
            const h = Math.floor(remaining / 3600000); const m = Math.floor((remaining % 3600000) / 60000); const s = Math.floor((remaining % 60000) / 1000);
             if(timerElement) timerElement.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
             const forceSubmitBtn = document.getElementById('force-submit-btn'); if (forceSubmitBtn) { forceSubmitBtn.classList.toggle('hidden', remaining / 60000 >= 5); }
              if(timerElement) timerElement.classList.remove('text-red-500');
        }
    }
    updateTimerDisplay();
    currentOnlineTestState.timerInterval = setInterval(updateTimerDisplay, 1000);
}

export async function displayCurrentQuestion() {
    console.log("[DisplayQuestion] State:", JSON.parse(JSON.stringify(currentOnlineTestState || {})));
    console.log("displayCurrentQuestion START");
    const container = document.getElementById('question-container');
    if (!currentOnlineTestState) { console.error("displayCurrentQuestion HALTED: currentOnlineTestState is null."); if (container) container.innerHTML = '<p class="text-red-500 p-4">Error: Test state lost.</p>'; else console.error("displayCurrentQuestion HALTED: Also #question-container not found."); return; }
    if (!container) { console.error("displayCurrentQuestion HALTED: Question container not found."); return; }
    const index = currentOnlineTestState.currentQuestionIndex; const questions = currentOnlineTestState.questions;
    if (index < 0 || !Array.isArray(questions) || questions.length === 0 || index >= questions.length) { console.error(`displayCurrentQuestion HALTED: Invalid index ${index}/${questions?.length}`); container.innerHTML = '<p class="text-red-500 p-4">Error: Invalid question index.</p>'; return; }
    const question = questions[index]; const totalQuestions = questions.length;
    if (!question) { console.error("displayCurrentQuestion HALTED: Missing question object at index", index); container.innerHTML = `<p class="text-red-500 p-4">Error: Could not load question data for question ${index + 1}.</p>`; return; }
    const questionId = String(question.id || `q-${index+1}`);
    let imageHtml = question.image ? `<img src="${question.image}" alt="Question Image" class="max-w-full h-auto mx-auto my-4 border dark:border-gray-600 rounded" onerror="this.style.display='none';">` : '';
    let answerAreaHtml = '';
    if (question.isProblem) {
        const currentAnswer = currentOnlineTestState.userAnswers[questionId] || '';
        answerAreaHtml = `
        <div class="mt-4 problem-input-container">
            <label for="problem-answer-preview-${questionId}" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Your Answer / Solution Steps (Live Preview):</label>
            <div id="latex-toolbar-${questionId}" class="latex-toolbar"><span class="text-xs text-gray-400 dark:text-gray-500 p-1">Loading LaTeX tools...</span></div>
            <div id="problem-answer-preview-${questionId}" tabindex="0" class="min-h-[120px] p-3 border border-t-0 rounded-b-md bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 prose prose-sm dark:prose-invert max-w-none pretty-scrollbar overflow-auto focus:ring-2 focus:ring-primary-500 focus:border-primary-500" style="max-height: 250px;" aria-label="Live LaTeX Preview" onclick="document.getElementById('problem-answer-input-${questionId}').focus();" onfocus="this.classList.add('ring-2', 'ring-primary-500', 'border-primary-500');" onblur="this.classList.remove('ring-2', 'ring-primary-500', 'border-primary-500');" title="Click to edit raw LaTeX below."></div>
            <div class="mt-2">
                <label for="problem-answer-input-${questionId}" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-0.5">Edit Raw LaTeX Code:</label>
                <textarea id="problem-answer-input-${questionId}" name="problemAnswer" rows="3" class="w-full p-2 border rounded-md dark:bg-gray-800 dark:border-gray-600 dark:text-gray-50 font-mono text-xs leading-normal" placeholder="Type raw LaTeX here..." oninput="window.recordAnswer('${questionId}', this.value); window.updateLatexPreview('${questionId}')" spellcheck="false">${escapeHtml(currentAnswer)}</textarea>
            </div>
            <p class="text-xs text-muted mt-1">Use toolbar or type LaTeX. Preview updates automatically.</p>
        </div>`;
    } else { 
         answerAreaHtml = (question.options?.length > 0) ? `<div class="space-y-3 mt-4">` + question.options.map(opt => {
             const qIdStr = String(questionId); const optLetterStr = String(opt.letter); const storedAnswer = String(currentOnlineTestState.userAnswers[qIdStr] ?? ''); const isChecked = storedAnswer === optLetterStr;
             return `<input type="radio" id="radio-${qIdStr}-${optLetterStr}" name="mcqOption-${qIdStr}" value="${opt.letter}" class="hidden" ${isChecked ? 'checked' : ''} onchange="window.recordAnswer('${qIdStr}', this.value)"><label for="radio-${qIdStr}-${optLetterStr}" class="option-label flex items-start space-x-3 p-3 border dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer"><div class="flex items-baseline w-full"><span class="font-mono w-6 text-right mr-2 shrink-0">${opt.letter}.</span><div class="flex-1 option-text-container">${opt.text}</div></div></label>`;
         }).join('') + `</div>` : '<p class="text-sm text-yellow-600 mt-4">(No MC options found)</p>';
    }
    container.innerHTML = `<div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg mb-4 animate-fade-in question-card"><p class="text-sm text-gray-500 dark:text-gray-400 mb-2">Question ${index + 1} / ${totalQuestions} ${question.chapter ? `(Chapter ${question.chapter})` : ''}</p>${imageHtml}<div class="prose dark:prose-invert max-w-none mb-4 question-text-container">${question.text}</div>${answerAreaHtml}</div>`;
    if (question.isProblem) { if (typeof window.generateLatexToolbar === 'function') window.generateLatexToolbar(questionId); if (typeof window.updateLatexPreview === 'function') window.updateLatexPreview(questionId); }
    try { if (typeof utilsRenderMathIn === 'function') await utilsRenderMathIn(container); else console.error("utilsRenderMathIn not available."); } catch (mathError) { console.error("MathJax render error:", mathError); }
    const prevBtn = document.getElementById('prev-btn'); const nextBtn = document.getElementById('next-btn'); const submitBtn = document.getElementById('submit-btn'); const counterSpan = document.getElementById('question-counter');
    if (prevBtn) prevBtn.disabled = (index === 0);
    if (counterSpan) counterSpan.textContent = `Question ${index + 1} / ${totalQuestions}`;
    if (nextBtn && submitBtn) { if (index === totalQuestions - 1) { nextBtn.classList.add('hidden'); submitBtn.classList.remove('hidden'); } else { nextBtn.classList.remove('hidden'); submitBtn.classList.add('hidden'); } }
    console.log("displayCurrentQuestion END");
}

window.updateLatexPreview = async function(questionId) {
    const textarea = document.getElementById(`problem-answer-input-${questionId}`);
    const previewArea = document.getElementById(`problem-answer-preview-${questionId}`);
    if (textarea && previewArea) {
        // Directly set the LaTeX content for MathJax to process.
        // MathJax.tex2svgPromise() is more for converting a single string,
        // for a block of content, just setting innerHTML and calling typeset is better.
        previewArea.innerHTML = textarea.value; // Render raw LaTeX
        try {
            await utilsRenderMathIn(previewArea); // Let MathJax find and render it
        } catch (e) {
            console.error("Error rendering LaTeX preview:", e);
            previewArea.innerHTML = `<p class="text-red-500 text-xs">Error rendering LaTeX. Check syntax.</p>`;
        }
    }
};


export function navigateQuestion(direction) {
    if (!currentOnlineTestState) return;
    const newIndex = currentOnlineTestState.currentQuestionIndex + direction;
    if (newIndex >= 0 && newIndex < currentOnlineTestState.questions.length) { 
        currentOnlineTestState.currentQuestionIndex = newIndex; 
        displayCurrentQuestion(); 
        // Optional: Play UI sound for navigation
        window.playUiSound?.('navigation_subtle'); 
    }
}

export function recordAnswer(questionId, answer) {
    if (!currentOnlineTestState) return;
    const qIdStr = String(questionId); const ansStr = String(answer);
    currentOnlineTestState.userAnswers[qIdStr] = ansStr;
    const question = currentOnlineTestState.questions.find(q => String(q.id || `q-${currentOnlineTestState.questions.indexOf(q)+1}`) === qIdStr);
    if (question && !question.isProblem) updateSelectedOptionUI(qIdStr, ansStr);
}

function updateSelectedOptionUI(questionId, selectedValue) {
    const container = document.getElementById('question-container'); if (!container) return;
    const radios = container.querySelectorAll(`input[type="radio"][name="mcqOption-${questionId}"]`);
    radios.forEach(radio => {
        const label = document.querySelector(`label[for="${radio.id}"]`);
        if (label) {
            const isChecked = radio.value === selectedValue;
            label.classList.toggle('ring-2', isChecked); label.classList.toggle('ring-primary-500', isChecked);
            label.classList.toggle('bg-primary-50', isChecked); label.classList.toggle('dark:bg-primary-700/30', isChecked);
        }
    });
}


export function confirmSubmitOnlineTest() {
     if (!currentOnlineTestState) return;
     const unanswered = currentOnlineTestState.questions.filter(q => {
        const answer = currentOnlineTestState.userAnswers[String(q.id || `q-${currentOnlineTestState.questions.indexOf(q)+1}`)];
        return answer === null || answer === undefined || (typeof answer === 'string' && answer.trim() === '');
    }).length;
    let msg = "Submit test?"; if (unanswered > 0) msg += `\n\n${unanswered} unanswered question(s).`;
    if (confirm(msg)) submitOnlineTest();
}
export function confirmForceSubmit() { 
    if (confirm("Submit test now? Any remaining time will be forfeited.")) submitOnlineTest();
}

export async function submitOnlineTest() {
    showLoading("Submitting and marking exam...");
    try {
        if (!currentOnlineTestState || currentOnlineTestState.status === 'submitting' || currentOnlineTestState.status === 'completed' || !currentUser) {
            if (currentOnlineTestState?.status !== 'submitting' && currentOnlineTestState?.status !== 'completed') {
                 alert("Error: Missing test data, user session, or test already submitted.");
            }
            hideLoading(); return;
        }
        currentOnlineTestState.status = 'submitting';
        if (currentOnlineTestState.timerInterval) clearInterval(currentOnlineTestState.timerInterval);
        currentOnlineTestState.timerInterval = null;

        if (onlineTestKeyListener) {
            document.removeEventListener('keydown', onlineTestKeyListener);
            onlineTestKeyListener = null;
            console.log("[Submit Test] Removed online test key listener.");
        }

        const testArea = document.getElementById('online-test-area');
        if (testArea) testArea.classList.add('hidden');
        await new Promise(resolve => setTimeout(resolve, 100));

        const isCourseActivity = !!currentOnlineTestState.courseContext?.isCourseActivity;
        const isSkipExam = currentOnlineTestState.courseContext?.activityType === 'skip_exam';
        const courseId = currentOnlineTestState.courseContext?.courseId;
        const activityType = currentOnlineTestState.courseContext?.activityType || 'testgen'; // Default to testgen if no specific type
        const activityId = currentOnlineTestState.courseContext?.activityId;
        const chapterNumForSkipExam = currentOnlineTestState.courseContext?.chapterNum;

        const examRecord = await storeExamResult(courseId, currentOnlineTestState, activityType);

        if (!examRecord || !examRecord.markingResults) {
            hideLoading(); alert("Issue processing exam results.");
            if (isCourseActivity && courseId) window.showCurrentAssignmentsExams?.(courseId);
            else showTestGenerationDashboard();
            setCurrentOnlineTestState(null); return;
        }

        if (isCourseActivity && courseId) {
            const progress = userCourseProgressMap.get(courseId);
            if (progress) {
                const percentageScore = examRecord.markingResults.maxPossibleScore > 0
                    ? (examRecord.markingResults.totalScore / examRecord.markingResults.maxPossibleScore) * 100 : 0;
                
                switch (activityType) {
                    case 'assignment':
                        progress.assignmentScores = progress.assignmentScores || {};
                        progress.assignmentScores[activityId] = percentageScore;
                        const todayStr = getFormattedDate();
                        progress.dailyProgress = progress.dailyProgress || {};
                        progress.dailyProgress[todayStr] = progress.dailyProgress[todayStr] || { chaptersStudied: [], skipExamsPassed: [], assignmentCompleted: false, assignmentScore: null };
                        progress.dailyProgress[todayStr].assignmentCompleted = true;
                        progress.dailyProgress[todayStr].assignmentScore = percentageScore;
                        break;
                    case 'weekly_exam': progress.weeklyExamScores = progress.weeklyExamScores || {}; progress.weeklyExamScores[activityId] = percentageScore; break;
                    case 'final':
                        progress.finalExamScores = progress.finalExamScores || [];
                        const finalExamNumMatch = activityId.match(/final(\d+)/);
                        if (finalExamNumMatch) { const attemptIndex = parseInt(finalExamNumMatch[1], 10) - 1; if (attemptIndex >= 0) { while (progress.finalExamScores.length <= attemptIndex) progress.finalExamScores.push(null); progress.finalExamScores[attemptIndex] = percentageScore; } }
                        break;
                    case 'midcourse': progress.midcourseExamScores = progress.midcourseExamScores || {}; progress.midcourseExamScores[activityId] = percentageScore; break;
                    case 'skip_exam': break; 
                }

                progress.totalMark = calculateTotalMark(progress); 
                progress.grade = getLetterGrade(progress.totalMark); 

                updateUserCourseProgress(courseId, progress);
                await saveUserCourseProgress(currentUser.uid, courseId, progress);
            }
        }

        currentOnlineTestState.status = 'completed';
        await displayOnlineTestResults(examRecord);

        if (isSkipExam && chapterNumForSkipExam && courseId && examRecord.markingResults.maxPossibleScore > 0) {
            const percentage = (examRecord.markingResults.totalScore / examRecord.markingResults.maxPossibleScore) * 100;
            const progress = userCourseProgressMap.get(courseId);
            if (progress) {
                 progress.lastSkipExamScore = progress.lastSkipExamScore || {}; progress.lastSkipExamScore[chapterNumForSkipExam] = percentage;
                 progress.skipExamAttempts = progress.skipExamAttempts || {}; progress.skipExamAttempts[chapterNumForSkipExam] = (progress.skipExamAttempts[chapterNumForSkipExam] || 0) + 1;
                 const todayStr = getFormattedDate();
                 progress.dailyProgress = progress.dailyProgress || {};
                 progress.dailyProgress[todayStr] = progress.dailyProgress[todayStr] || { chaptersStudied: [], skipExamsPassed: [], assignmentCompleted: false, assignmentScore: null };
                 if (percentage >= SKIP_EXAM_PASSING_PERCENT) {
                     if (!progress.dailyProgress[todayStr].skipExamsPassed.includes(chapterNumForSkipExam)) { progress.dailyProgress[todayStr].skipExamsPassed.push(chapterNumForSkipExam); progress.dailyProgress[todayStr].skipExamsPassed.sort((a,b) => a - b); }
                     await markChapterStudiedInCourse(currentUser.uid, courseId, chapterNumForSkipExam, "skip_exam_passed");
                 } else { await saveUserCourseProgress(currentUser.uid, courseId, progress); }
            }
        } else if (!isCourseActivity && currentSubject && data?.subjects?.[currentSubject.id]) {
            // --- START MODIFIED: TestGen Bonus Logic ---
            let chaptersDataModified = false;
            const subjectToUpdate = data.subjects[currentSubject.id];
            if (examRecord.questions && examRecord.markingResults?.questionResults) {
                 examRecord.markingResults.questionResults.forEach(result => {
                      const question = examRecord.questions.find(q => q.id === result.questionId);
                      if (question && question.chapter) {
                           const chap = subjectToUpdate.chapters[question.chapter];
                           if (chap) {
                                if (!question.isProblem) { // Only update MCQ stats in TestGen progress
                                     chap.total_attempted = (chap.total_attempted || 0) + 1;
                                     const isCorrect = result.score > 0; // Assuming MCQ score is > 0 if correct
                                     if (!isCorrect) chap.total_wrong = (chap.total_wrong || 0) + 1;
                                     chap.mistake_history = chap.mistake_history || []; chap.mistake_history.push(isCorrect ? 0 : 1);
                                     if (chap.mistake_history.length > 20) chap.mistake_history.shift();
                                     chap.consecutive_mastery = isCorrect ? (chap.consecutive_mastery || 0) + 1 : 0;
                                     chaptersDataModified = true;
                                     // Remove from available_questions
                                     if (chap.available_questions && Array.isArray(chap.available_questions) && question.number) {
                                          const qIndex = chap.available_questions.indexOf(question.number); // Assuming question.number is the MCQ number
                                          if (qIndex > -1) chap.available_questions.splice(qIndex, 1);
                                      }
                                }
                           }
                      }
                  });
            }
            if (chaptersDataModified) {
                Object.values(subjectToUpdate.chapters).forEach(chap => { if (chap.available_questions) chap.available_questions.sort((a, b) => a - b); });
                await saveUserData(currentUser.uid, data); // Save updated appData
            }

            // Award TestGen Bonus
            if (examRecord.subjectId && examRecord.markingResults && examRecord.markingResults.maxPossibleScore > 0) {
                let bonusAppliedToCourseId = null;
                const testGenScorePercent = (examRecord.markingResults.totalScore / examRecord.markingResults.maxPossibleScore); // Ratio 0-1

                if (testGenScorePercent > 0.5) { // Example: Give bonus if score > 50%
                    const bonusPoints = Math.min(MAX_BONUS_FROM_TESTGEN, testGenScorePercent * MAX_BONUS_FROM_TESTGEN);

                    // Determine which course (if any) to apply the bonus to
                    if (activeCourseId && userCourseProgressMap.has(activeCourseId)) {
                        const activeCourseDef = globalCourseDataMap.get(activeCourseId);
                        if (activeCourseDef && activeCourseDef.relatedSubjectId === examRecord.subjectId) {
                            bonusAppliedToCourseId = activeCourseId;
                        }
                    }
                    if (!bonusAppliedToCourseId) { // If not active course, find first relevant enrolled course
                        for (const [enrolledCId, enrolledProgress] of userCourseProgressMap.entries()) {
                            const enrolledCourseDef = globalCourseDataMap.get(enrolledCId);
                            if (enrolledCourseDef && enrolledCourseDef.relatedSubjectId === examRecord.subjectId && enrolledProgress.status === 'enrolled') {
                                bonusAppliedToCourseId = enrolledCId;
                                break;
                            }
                        }
                    }

                    if (bonusAppliedToCourseId) {
                        const courseProgressToUpdate = userCourseProgressMap.get(bonusAppliedToCourseId);
                        if (courseProgressToUpdate) {
                            const oldBonus = courseProgressToUpdate.testGenBonus || 0;
                            const newTotalBonus = Math.min(oldBonus + bonusPoints, MAX_TOTAL_TESTGEN_BONUS_CAP_FOR_COURSE);
                            courseProgressToUpdate.testGenBonus = newTotalBonus;
                            
                            // Recalculate overall mark and grade for the course
                            courseProgressToUpdate.totalMark = calculateTotalMark(courseProgressToUpdate);
                            courseProgressToUpdate.grade = getLetterGrade(courseProgressToUpdate.totalMark);

                            await saveUserCourseProgress(currentUser.uid, bonusAppliedToCourseId, courseProgressToUpdate);
                            updateUserCourseProgress(bonusAppliedToCourseId, courseProgressToUpdate); // Update local state
                            
                            const courseNameForBonus = globalCourseDataMap.get(bonusAppliedToCourseId)?.name || `Course ${bonusAppliedToCourseId}`;
                            const toastContainer = document.createElement('div');
                            toastContainer.innerHTML = `<div class="toast-notification toast-success animate-fade-in"><p>+${bonusPoints.toFixed(1)} TestGen Bonus applied to course: ${escapeHtml(courseNameForBonus)}!</p><p class="text-xs">New total TestGen bonus for course: ${newTotalBonus.toFixed(1)}/${MAX_TOTAL_TESTGEN_BONUS_CAP_FOR_COURSE}</p></div>`;
                            document.body.appendChild(toastContainer);
                            setTimeout(() => toastContainer.remove(), 6000);
                        }
                    }
                }
            }
            // --- END MODIFIED ---
        }
        setCurrentOnlineTestState(null);
    } catch (error) {
        console.error("Error finishing test:", error);
        setCurrentOnlineTestState(null); alert("Error submitting test: " + error.message);
        const isCourseActivityOnError = !!currentOnlineTestState?.courseContext?.isCourseActivity;
        const courseIdOnError = currentOnlineTestState?.courseContext?.courseId;
        if (isCourseActivityOnError && courseIdOnError) window.showCurrentAssignmentsExams?.(courseIdOnError);
        else showTestGenerationDashboard();
    } finally {
        hideLoading();
    }
}

export async function displayOnlineTestResults(examRecord) {
    clearContent();
    if (!examRecord || !examRecord.markingResults) { displayContent('<p class="text-red-500 p-4">Error displaying results.</p>'); return; }
    const examId = examRecord.id || examRecord.examId;
    if (!examId) { displayContent('<p class="text-red-500 p-4">Error: Could not find exam identifier.</p>'); return; }
    const { markingResults, courseContext, timestamp, type, subjectId, courseId } = examRecord;
    const score = markingResults?.totalScore ?? 0; const maxScore = markingResults?.maxPossibleScore ?? 0;
    const percentage = maxScore > 0 ? ((score / maxScore) * 100).toFixed(1) : 0;
    const dateTimestamp = (timestamp?.toDate ? timestamp.toDate() : (typeof timestamp === 'number' ? new Date(timestamp) : new Date()));
    const date = dateTimestamp.toLocaleString();
    const durationMinutes = examRecord.durationMinutes; const isCourse = !!courseId; const isSkip = type === 'skip_exam';
    const contextName = isCourse ? (globalCourseDataMap.get(courseId)?.name || courseId) : subjectId ? (window.data?.subjects?.[subjectId]?.name || subjectId) : (examRecord.isTestGen ? 'Standard TestGen' : 'General Test');
    let passThreshold = PASSING_GRADE_PERCENT; if (isSkip) passThreshold = SKIP_EXAM_PASSING_PERCENT;
    const isPassing = parseFloat(percentage) >= passThreshold;
    const typeDisplay = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

    // --- START MODIFIED: Added Download Feedback PDF button ---
    const downloadFeedbackButtonHtml = `
        <button onclick="window.downloadExamFeedbackPdfWrapper('${examId}')" class="btn-secondary">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
            Download Feedback PDF
        </button>
    `;
    // --- END MODIFIED ---

    const resultsHtml = `
        <div class="space-y-6 animate-fade-in max-w-3xl mx-auto">
            <div class="text-center p-6 bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700">
                <h2 class="text-2xl font-bold mb-2">Exam Results</h2>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-1">Exam ID: ${escapeHtml(examId)}</p>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-1">Context: ${escapeHtml(contextName)} (${isCourse ? 'Course' : 'Subject'}) | Type: ${escapeHtml(typeDisplay)}</p>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Completed: ${date} ${durationMinutes ? `(${durationMinutes} min)` : ''}</p>
                <div class="text-5xl font-bold ${isPassing ? 'text-green-600' : 'text-red-600'} mb-2">${percentage}%</div>
                <p class="text-lg text-gray-600 dark:text-gray-400 mb-2">${score.toFixed(1)} out of ${maxScore.toFixed(1)} points</p>
                <p class="text-xl font-semibold ${isPassing ? 'text-green-600' : 'text-red-600'}">${isPassing ? 'PASS' : 'FAIL'} (Threshold: ${passThreshold}%)</p>
                 ${isSkip && isPassing ? `<p class="text-sm text-green-600 mt-1">Chapter ${courseContext?.chapterNum || '?'} marked as studied!</p>` : ''}
                 ${isSkip && !isPassing ? `<p class="text-sm text-red-600 mt-1">Needed ${passThreshold}% to pass skip exam.</p>` : ''}
            </div>
            ${markingResults.overallFeedback ? `<div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md border dark:border-gray-700 overall-feedback-area"><h3 class="text-lg font-semibold mb-4">Overall AI Feedback</h3><div class="space-y-4 text-sm"><p class="text-gray-700 dark:text-gray-300">${escapeHtml(markingResults.overallFeedback.overall_feedback||'N/A')}</p><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><h4 class="font-medium text-green-600 mb-2">Strengths</h4><ul class="list-disc list-inside text-gray-600 dark:text-gray-400">${markingResults.overallFeedback.strengths?.map(s=>`<li>${escapeHtml(s)}</li>`).join('')||'<li>N/A</li>'}</ul></div><div><h4 class="font-medium text-red-600 mb-2">Areas for Improvement</h4><ul class="list-disc list-inside text-gray-600 dark:text-gray-400">${markingResults.overallFeedback.weaknesses?.map(w=>`<li>${escapeHtml(w)}</li>`).join('')||'<li>N/A</li>'}</ul></div></div>${markingResults.overallFeedback.study_recommendations?`<div class="mt-4"><h4 class="font-medium text-blue-600 mb-2">Study Recommendations</h4><ul class="list-disc list-inside text-gray-600 dark:text-gray-400">${markingResults.overallFeedback.study_recommendations.map(r=>`<li>${escapeHtml(r)}</li>`).join('')||'<li>N/A</li>'}</ul></div>`:''}</div></div>`:'<p class="text-muted italic text-center my-4">No overall feedback.</p>'}
            <div class="flex justify-center gap-4 flex-wrap">
                <button onclick="window.showExamReviewUI('${currentUser.uid}', '${examId}')" class="btn-primary">View Detailed Review</button>
                ${downloadFeedbackButtonHtml} 
                <button onclick="${isCourse ? `window.showCurrentAssignmentsExams('${courseId}')` : 'window.showExamsDashboard()'}" class="btn-secondary">${isCourse ? 'Back to Course Exams' : 'Back to TestGen Exams'}</button>
                 ${!isCourse ? `<button onclick="window.showTestGenerationDashboard()" class="btn-secondary">Generate New Test</button>` : ''}
            </div>
        </div>`;
    displayContent(resultsHtml, 'content');
    setActiveSidebarLink(isCourse ? 'showCurrentAssignmentsExams' : 'showExamsDashboard', isCourse ? 'sidebar-course-nav' : 'testgen-dropdown-content');
    const overallFeedbackArea = document.querySelector('.overall-feedback-area');
    if (overallFeedbackArea) await utilsRenderMathIn(overallFeedbackArea);
}

// --- MODIFIED: Wrapper for Download Feedback PDF ---
window.downloadExamFeedbackPdfWrapper = async (examId) => {
    if (!currentUser || !examId) {
        alert("Cannot download feedback: User or Exam ID missing.");
        return;
    }
    showLoading("Preparing Feedback PDF...");
    try {
        const examDetails = await getExamDetails(currentUser.uid, examId);
        if (!examDetails) {
            throw new Error("Could not load exam details for PDF generation.");
        }

        // Fetch AI explanations for each question (or use stored ones if available)
        const feedbackDetails = {};
        if (examDetails.questions && examDetails.markingResults?.questionResults) {
            for (let i = 0; i < examDetails.questions.length; i++) {
                const question = examDetails.questions[i];
                const qId = question.id || `q-${i+1}`;
                // This is a placeholder. In a real scenario, if explanations are generated
                // on-demand and not stored with the exam, you might need to fetch/generate them here.
                // For simplicity, assume explanations could be part of examDetails or fetched.
                // If they are fetched on demand when viewing the review, then the PDF might not include them
                // unless we regenerate them all here, which could be slow.
                // For now, let's assume we pass an empty explanation or one from a hypothetical field.
                feedbackDetails[qId] = {
                    explanationHtml: examDetails.aiExplanations?.[qId] || "AI Explanation not available in this PDF version."
                };
            }
        }

        const htmlContent = generateExamFeedbackPdfHtml(examId, examDetails, feedbackDetails);
        const filename = `Exam_Feedback_${examId}`;
        await generateAndDownloadPdfWithMathJax(htmlContent, filename);

    } catch (error) {
        console.error("Error generating feedback PDF:", error);
        alert(`Failed to generate feedback PDF: ${error.message}`);
    } finally {
        hideLoading();
    }
};

// --- END MODIFIED ---

window.showExamReviewUI = showExamReviewUI;
window.showIssueReportingModal = showIssueReportingModal;
window.submitIssueReport = submitIssueReport;
export { setCurrentOnlineTestState, deleteTestgenExam as deleteCompletedExamV2 };
// --- END OF FILE ui_online_test.js ---