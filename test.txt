// --- START OF FILE ui_pdf_generation.js ---

import { PDF_GENERATION_OPTIONS, LATEX_DOCUMENT_CLASS, LATEX_PACKAGES, LATEX_BEGIN_DOCUMENT, LATEX_END_DOCUMENT } from './config.js';
import { showLoading, hideLoading, renderMathIn, escapeHtml } from './utils.js';

// generatePdfBaseHtml, generatePdfHtml, generateNotePdfHtml, generateTexSource, downloadTexFile
// remain IDENTICAL to the previous good version you had (the one focusing on better styling for PDF).
// I'll include them here for completeness.

function generatePdfBaseHtml(title, innerContentHtml) {
    const escapedTitle = escapeHtml(title);
    const styles = `
        body {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 11pt; 
            color: #000000 !important; 
            background-color: #ffffff !important; 
            margin: 1.5cm; 
            padding: 0;
            line-height: 1.4;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #000000 !important; 
            font-family: Arial, Helvetica, sans-serif;
            margin-top: 1em;
            margin-bottom: 0.5em;
            font-weight: bold;
            line-height: 1.2;
        }
        h1 { font-size: 18pt; text-align: center; margin-bottom: 0.7cm; border-bottom: 1.5px solid #333333; padding-bottom: 0.2cm; }
        h2 { font-size: 15pt; margin-bottom: 0.5cm; border-bottom: 1px solid #555555; padding-bottom: 0.15cm;}
        p {
            margin-bottom: 0.6em;
            text-align: left; 
            color: #000000 !important; 
        }
        ul, ol {
            margin-bottom: 0.6em;
            padding-left: 1.8em; 
        }
        li {
            margin-bottom: 0.25em;
            color: #000000 !important;
        }
        /* MathJax SVG styling */
        mjx-container svg { display: inline-block; }
        mjx-container svg g[fill] { fill: black !important; }
        mjx-container svg g[stroke] { stroke: black !important; }
        mjx-container:not([display="true"]) { vertical-align: -0.2ex !important; margin: 0 0.05em !important; }
        mjx-container[display="true"] { margin: 0.8em auto !important; display: block !important; text-align: left !important; }
        .keep-together { page-break-inside: avoid !important; }
    `;

    const mathJaxConfigAndScript = `
        <script>
          window.MathJax = {
            loader: { load: ['input/tex', 'output/svg'] },
            tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']] },
            svg: { fontCache: 'global', scale: 1, mtextInheritFont: true, merrorInheritFont: true, displayAlign: 'left', displayIndent: '0em'},
            startup: {
                ready: () => {
                    console.log('[PDF HTML Inner] MathJax Startup: Ready function called.');
                    MathJax.startup.defaultReady(); // This is important!
                    MathJax.startup.promise.then(() => {
                        console.log('[PDF HTML Inner] MathJax Startup: Main promise resolved. Setting window flag now.');
                        window.mathJaxIsCompletelyReadyForPdf = true; // Signal readiness
                        console.log('[PDF HTML Inner] window.mathJaxIsCompletelyReadyForPdf SET TO TRUE.');
                    }).catch(err => {
                        console.error('[PDF HTML Inner] MathJax startup.promise REJECTED:', err);
                        window.mathJaxIsCompletelyReadyForPdf = 'error'; // Signal an error state
                    });
                }
            }
          };
        </script>
        <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js" id="mathjax-pdf-script"></script>
    `;
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <title>${escapedTitle}</title>
            <meta charset="UTF-8">
            <style>${styles}</style>
            ${mathJaxConfigAndScript}
        </head>
        <body style="color: #000000; background-color: #ffffff;">
            <h1>${escapedTitle}</h1>
            <div class="content" style="color: #000000;">${innerContentHtml}</div>
        </body>
        </html>
    `;
}

export function generatePdfHtml(examId, questions) {
    const placeholderText = '[Content Missing]';
    let questionItemsHtml = '';
    let solutionItemsHtml = '';
    const examSpecificStyles = `
        <style>
            .pdf-subtitle { font-size: 16pt !important; font-weight: bold; margin-top: 1cm; margin-bottom: 0.4cm; text-align: center; border-bottom: 1.5px solid #333; padding-bottom: 0.2cm; }
            .exam-details { font-size: 10pt !important; color: #222 !important; margin-bottom: 0.5cm; text-align: center; }
            .question-list { list-style-type: decimal; padding-left: 1.6em; }
            .question-item-wrapper { margin-bottom: 0.8cm; padding-bottom: 0.4cm; border-bottom: 1px solid #e0e0e0; }
            .question-item-wrapper:last-child { border-bottom: none; }
            .question-header { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: bold; margin-bottom: 0.3cm; font-size: 13pt !important; color: #111 !important; }
            .question-text { margin-bottom: 0.4cm; font-size: 11pt !important; line-height: 1.5 !important; text-align: left; }
            .question-image-container { text-align: center; margin: 0.5cm 0; page-break-inside: avoid; }
            .question-image { max-width: 85%; max-height: 240px; display: inline-block; border: 1px solid #ccc; padding: 2px; background-color: #fff; }
            .options-list { list-style-type: none; padding-left: 0.5em; margin-top: 0.3cm; page-break-inside: avoid; }
            .option-item { display: flex; align-items: flex-start; margin-bottom: 0.2cm; font-size: 11pt !important; }
            .option-letter { font-family: Arial, Helvetica, sans-serif; font-weight: bold; margin-right: 0.5em; width: 1.6em; text-align: right; color: #004a7c !important; }
            .option-text { flex-grow: 1; text-align: left; }
            .solution-section { margin-top: 0.5cm; padding-top: 0.3cm; border-top: 1px solid #28a745; page-break-inside: avoid; }
            .solution-label { font-family: Arial, Helvetica, sans-serif; font-weight: bold; color: #1e7e34 !important; font-size: 12pt !important; }
            p, li, div, span { color: #000000 !important; } /* Catch-all for text color */
        </style>`;

    let imageBasePath = '';
    if (window.currentSubject && window.currentSubject.courseDirName) {
        const courseBasePath = (typeof window.COURSE_BASE_PATH === 'string' && window.COURSE_BASE_PATH !== "./courses") ? window.COURSE_BASE_PATH : "courses";
        const subjectResourceFolder = typeof window.SUBJECT_RESOURCE_FOLDER === 'string' ? window.SUBJECT_RESOURCE_FOLDER : 'Problems';
        imageBasePath = `${courseBasePath}/${window.currentSubject.courseDirName}/${subjectResourceFolder}/images/`;
    } else { imageBasePath = 'assets/images/'; }

    questions.forEach((q, index) => {
        const questionNumber = index + 1;
        let qTextForHtml = q.text || placeholderText;
        let optionsForHtml = '';
        let solutionAnswerText = q.isProblem ? 'Solution details vary.' : (q.correctAnswer ? escapeHtml(q.correctAnswer) : 'N/A');

        if (!q.isProblem && q.options && q.options.length > 0) {
            optionsForHtml = `<ol class="options-list">` +
                (q.options || []).map(opt => {
                    let optTextForHtml = opt.text || placeholderText;
                    return `<li class="option-item"><span class="option-letter">${escapeHtml(opt.letter)}.</span><span class="option-text">${optTextForHtml}</span></li>`;
                }).join('') + `</ol>`;
        }
        let imageSrc = null;
        if (q.image && typeof q.image === 'string') {
            let imageName = q.image;
            if (imageName.startsWith('./images/')) imageName = imageName.substring(9);
            else if (imageName.startsWith('images/')) imageName = imageName.substring(7);
            else if (imageName.startsWith('./')) imageName = imageName.substring(2);
            imageSrc = `${imageBasePath}${imageName.split('?')[0]}`;
            imageSrc = imageSrc.replace(/\/{2,}/g, '/');
        }
        let imageHtml = imageSrc ? `<div class="question-image-container"><img src="${escapeHtml(imageSrc)}" alt="Image" class="question-image" crossorigin="anonymous"></div>` : '';

        const questionItemContent = `
            <div class="question-header">Question ${questionNumber}${q.chapter ? ` (Ch ${q.chapter})` : ''}${q.isProblem ? ' (Problem)' : ''}</div>
            <div class="question-text">${qTextForHtml}</div> 
            ${imageHtml}
            ${optionsForHtml || ''}
        `;
        questionItemsHtml += `<li class="question-item-wrapper">${questionItemContent}</li>`;
        solutionItemsHtml += `
            <li class="question-item-wrapper">
                ${questionItemContent}
                <div class="solution-section"><span class="solution-label">Answer:</span> ${solutionAnswerText}</div>
            </li>`;
    });
    const examHeaderHtml = `<div class="exam-details">Total Questions: ${questions.length}</div>`;
    const questionListContent = `<div class="pdf-subtitle">Questions</div><ol class="question-list">${questionItemsHtml}</ol>`;
    const solutionListContent = `<div class="pdf-subtitle">Solutions</div><ol class="question-list">${solutionItemsHtml}</ol>`;
    const finalQuestionHtml = generatePdfBaseHtml(`Exam: ${examId}`, examHeaderHtml + questionListContent)
        .replace('</head>', `${examSpecificStyles}</head>`);
    const finalSolutionHtml = generatePdfBaseHtml(`Solutions: ${examId}`, examHeaderHtml + solutionListContent)
        .replace('</head>', `${examSpecificStyles}</head>`);
    return { questionHtml: finalQuestionHtml, solutionHtml: finalSolutionHtml };
}

export function generateNotePdfHtml(note) {
    const noteTitle = note.title || '[Content Missing]';
    let noteContent = note.content || '[Content Missing]';
    const dateStr = note.timestamp ? new Date(note.timestamp).toLocaleString() : 'N/A';
    const titleSuffix = note.filename ? ` (from file: ${escapeHtml(note.filename)})` : '';
    const noteSpecificStyles = `<style> h1 {font-size: 18pt;} .note-meta { font-size: 9pt; color: #333; margin-bottom: 0.5cm; border-bottom: 1px solid #ccc; padding-bottom: 0.2cm; } </style>`;
    let contentForPdf = '';
    if (note.type === 'latex' || note.type === 'ai_review') contentForPdf = `<div>${noteContent}</div>`;
    else contentForPdf = `<div>${escapeHtml(noteContent).replace(/\n/g, '<br>\n')}</div>`;
    const innerHtml = `<div class="note-meta">Chapter ${note.chapterNum || 'N/A'} | Updated: ${dateStr}${titleSuffix}</div>${contentForPdf}`;
    return generatePdfBaseHtml(`Note: ${noteTitle}`, innerHtml).replace('</head>', `${noteSpecificStyles}</head>`);
}


/**
 * Generates PDF by sending HTML content to a local Node.js server.
 * @param {string} htmlContent - The full HTML string to convert.
 * @param {string} baseFilename - The base filename for the downloaded PDF.
 */
export async function generateAndDownloadPdfWithMathJax(htmlContent, baseFilename) {
    showLoading(`Requesting PDF generation for: ${baseFilename}...`);
    const PDF_SERVER_URL = 'http://localhost:3001/generate-pdf'; // Ensure this matches your server

    try {
        const response = await fetch(PDF_SERVER_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                htmlContent: htmlContent,
                filename: `${baseFilename}.pdf`
            }),
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`PDF server error: ${response.status} - ${errorText}`);
        }

        const pdfBlob = await response.blob();
        const downloadUrl = window.URL.createObjectURL(pdfBlob);
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = `${baseFilename}.pdf`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(downloadUrl);
        console.log(`[PDF Client] PDF '${baseFilename}.pdf' downloaded successfully.`);

    } catch (error) {
        console.error(`[PDF Client] Error generating or downloading PDF for '${baseFilename}':`, error);
        alert(`Failed to generate PDF: ${baseFilename}. Error: ${error.message}. Ensure the local PDF server is running and accessible.`);
    } finally {
        hideLoading();
    }
}


export function generateTexSource(examId, questions) {
    const placeholderText = '[Content Missing]';
    const escapeLatex = (str) => {
        if (str === null || typeof str === 'undefined') str = placeholderText;
        str = String(str);
        let mathSegments = [];
        let placeholderCounter = 0;
        const placeholderPrefix = "@@LATEX_PLACEHOLDER_";
        const placeholderSuffix = "@@END_LATEX_PLACEHOLDER";
        let processedStr = str.replace(
            /(\$\$[\s\S]*?\$\$|\\\[[\s\S]*?\\\]|(?<!\\)\$(?:[^\$\\]|\\.)*?\$|\\\(.*?\\\))/g,
            (match) => {
                const placeholder = `${placeholderPrefix}${placeholderCounter++}${placeholderSuffix}`;
                mathSegments.push({ placeholder, math: match });
                return placeholder;
            }
        );
        processedStr = processedStr
            .replace(/\\/g, '\\textbackslash{}') 
            .replace(/~/g, '\\textasciitilde{}')
            .replace(/\^/g, '\\textasciicircum{}')
            .replace(/&/g, '\\&')
            .replace(/%/g, '\\%')
            .replace(/\$/g, '\\$') 
            .replace(/#/g, '\\#')
            .replace(/_/g, '\\_')
            .replace(/{/g, '\\{')
            .replace(/}/g, '\\}')
            .replace(/>/g, '\\textgreater{}')
            .replace(/</g, '\\textless{}')
            .replace(/\n\n/g, '\\par\\medskip\n') 
            .replace(/\n/g, '\\\\ \n');          
        mathSegments.forEach(item => {
            const regexSafePlaceholder = item.placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(regexSafePlaceholder, 'g');
            processedStr = processedStr.replace(regex, item.math);
        });
        return processedStr;
    };

    let questionsBody = '';
    let solutionsBody = '';
    const examIdTex = escapeLatex(examId || placeholderText);

    questions.forEach((q, index) => {
        const questionNumber = index + 1;
        let qTextForTex = escapeLatex(q.text); 
        let imageTex = '';
        if (q.image) {
             const safeImageFilename = q.image.replace(/[{}\\^%&#_ ]/g, '-').split('/').pop(); 
             imageTex = `\\begin{center}\n\\includegraphics[width=0.6\\textwidth,keepaspectratio]{images/${safeImageFilename}}\n\\end{center}\n`;
        }
        let optionsText = '';
        let solutionAnswer = q.isProblem ? 'Solution details vary.' : escapeLatex(q.correctAnswer || 'N/A');
        if (!q.isProblem && q.options && q.options.length > 0) {
             optionsText = (q.options || []).map(opt => `\\item[${escapeLatex(opt.letter)}.] ${escapeLatex(opt.text)}`).join('\n      ');
        }
        let optionsBlock = optionsText ? `    \\begin{itemize}[labelwidth=!, labelindent=0pt, leftmargin=*, itemsep=0.2em]\n      ${optionsText}\n    \\end{itemize}\n` : '';
        
        questionsBody += `\\item ${qTextForTex}\n${imageTex}${optionsBlock}\n\\vspace{0.5cm}\n`;
        solutionsBody += `\\item ${qTextForTex}\n${imageTex}${optionsBlock}\n    \\textbf{Answer: ${solutionAnswer}}\n\\vspace{0.5cm}\n`;
    });

    const fullDocumentPreamble = `${LATEX_DOCUMENT_CLASS}\n${LATEX_PACKAGES}\\usepackage{graphicx}\n\\graphicspath{{./images/}} \n\\title{Exam: ${examIdTex}}\n\\author{Lyceum}\n\\date{\\today}\n${LATEX_BEGIN_DOCUMENT}\n\\maketitle\n\\parindent0pt\n\\sloppy\n\n`; 
    const questionsTex = `${fullDocumentPreamble}\\section*{Questions}\n\\begin{enumerate}[label=\\arabic*., itemsep=0.5cm, topsep=0.2cm]\n\n${questionsBody}\\end{enumerate}\n\n${LATEX_END_DOCUMENT}`;
    const solutionsTex = `${fullDocumentPreamble}\\section*{Solutions}\n\\begin{enumerate}[label=\\arabic*., itemsep=0.5cm, topsep=0.2cm]\n\n${solutionsBody}\\end{enumerate}\n\n${LATEX_END_DOCUMENT}`;
    return { questionsTex, solutionsTex };
}

export function downloadTexFile(filename, base64Content) {
     try {
         const decodedContent = atob(base64Content);
         const utf8Encoder = new TextEncoder(); 
         const utf8ByteArray = utf8Encoder.encode(decodedContent);
         const blob = new Blob([utf8ByteArray], { type: "text/plain;charset=utf-8" });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = filename;
         document.body.appendChild(a);
         a.click();
         document.body.removeChild(a);
         URL.revokeObjectURL(url);
     } catch (e) {
         console.error("Error creating/downloading .tex file:", e);
         alert(`Failed to prepare the download file (${filename}). Error: ${e.message}. See console for details.`);
     }
}
// --- END OF FILE ui_pdf_generation.js ---