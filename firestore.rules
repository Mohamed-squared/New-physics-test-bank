rules_version = '2'; 
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isLoggedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isLoggedIn() && request.auth.uid == userId;
    }

    function isPrimaryAdminUid(uid) {
      return uid == "04amtH9UgfTWxPH0rqn2quaKiNf1";
    }

    function isPrimaryAdmin() {
      return isLoggedIn() && isPrimaryAdminUid(request.auth.uid);
    }

    function isAssignedAdmin(uid) {
      return exists(/databases/$(database)/documents/users/$(uid)) &&
             get(/databases/$(database)/documents/users/$(uid)).data.isAdmin == true;
    }

    function isAdmin() {
       return isLoggedIn() && (isPrimaryAdminUid(request.auth.uid) || isAssignedAdmin(request.auth.uid));
    }

    function isValidString(str, minLength, maxLength) {
      return str is string && str.size() >= minLength && str.size() <= maxLength;
    }

    function isValidNumber(num, minVal, maxVal) {
        return num is number && num >= minVal && num <= maxVal;
    }

    function allowedUserUpdateFieldsOwner() {
      return [
        'displayName', 'photoURL', 'onboardingComplete', 'lastSelectedSubjectId',
        'appData', 'userNotes', 'userAiChatSettings', 'completedCourseBadges',
        'lastAppDataUpdate'
      ];
    }

    function allowedAdminUpdateFieldsOnOtherUser() {
      return allowedUserUpdateFieldsOwner().concat(['isAdmin', 'credits', 'username']);
    }

    function allowedAdminUpdateFieldsOnSelf() {
      return allowedUserUpdateFieldsOwner().concat(['credits']);
    }

    function allowedCourseProgressUpdateFieldsAdmin() {
        return [
            'enrollmentDate', 'baseMediocrePace', 'courseStudiedChapters', 'pdfProgress',
            'watchedVideoDurations', 'lastActivityDate', 'assignmentScores', 'weeklyExamScores',
            'midcourseExamScores', 'finalExamScores', 'lastSkipExamScore', 'skipExamAttempts',
            'dailyProgress', 'status', 'totalMark', 'grade', 'completionDate',
            'userRating', 'userReview', 'selectedPace', 'customPaceDays', 'currentPace',
            'currentChapterTarget', 'currentDayObjective', 'attendanceScore', 'extraPracticeBonus',
            'enrollmentMode', 'testGenBonus'
        ];
    }

    function allowedCourseProgressUpdateFieldsOwner() {
        return [
            'lastActivityDate', 'pdfProgress', 'watchedVideoDurations',
            'courseStudiedChapters', 'dailyProgress', 'userRating', 'userReview',
            'status',
            'selectedPace', 'customPaceDays'
        ];
    }

    function isValidExamTypeConfig(config) {
      return config is map &&
             config.keys().hasAll(['questions', 'durationMinutes', 'mcqRatio', 'textSourceRatio']) &&
             config.keys().size() == 4 &&
             config.questions is number && config.questions >= 1 &&
             config.durationMinutes is number && config.durationMinutes >= 5 &&
             config.mcqRatio is number && config.mcqRatio >= 0 && config.mcqRatio <= 1 &&
             config.textSourceRatio is number && config.textSourceRatio >= 0 && config.textSourceRatio <= 1;
    }

    // --- Helper function for Test Gen Config (can be expanded) ---
    function isValidTestGenConfig(config) {
      return config is map &&
             config.keys().hasAll(['textMcqCount', 'textProblemCount', 'lectureMcqCounts', 'lectureProblemCounts', 'timingOption']) &&
             config.textMcqCount is number && config.textMcqCount >= 0 &&
             config.textProblemCount is number && config.textProblemCount >= 0 &&
             config.lectureMcqCounts is map && // keys are lecture IDs (strings), values are numbers
             config.lectureProblemCounts is map && // keys are lecture IDs (strings), values are numbers
             config.timingOption is string && (config.timingOption == 'default' || config.timingOption == 'calculated' || config.timingOption == 'custom') &&
             (config.timingOption != 'custom' || (config.timingOption == 'custom' && config.customDurationMinutes is number && config.customDurationMinutes >= 10)) &&
             // Min 10 questions validation is hard to do directly in rules for sums of map values.
             // Best handled client-side / Cloud Function before write.
             // We can check individual counts are not excessively large if needed.
             true; // Add more checks if necessary, e.g., map values are numbers >= 0
    }


    match /userExams/{userId}/exams/{examId} {
      allow read: if isLoggedIn() && (isOwner(userId) || isAdmin());
      allow create: if isLoggedIn() && isOwner(userId) &&
                       request.resource.data.userId == userId &&
                       request.resource.data.examId == examId && // examId is typically generated client-side
                       request.resource.data.courseId is string && // Need courseId to link to subject for default timing
                       request.resource.data.questions is list && // Populated based on config
                       request.resource.data.answers is map && // User's answers
                       request.resource.data.markingResults is map && // Auto-grading results
                       request.resource.data.score is number && request.resource.data.score >= 0 &&
                       request.resource.data.maxScore is number && request.resource.data.maxScore > 0 &&
                       request.resource.data.status is string && (request.resource.data.status == 'started' || request.resource.data.status == 'completed') &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.completedAt == (request.resource.data.status == 'completed' ? request.time : null) &&
                       request.resource.data.durationMinutes is number && request.resource.data.durationMinutes >= 5 && // Final duration
                       request.resource.data.isTestGen is bool &&
                       (
                         ( request.resource.data.isTestGen == false &&
                           // For regular exams, ensure no testGenConfig is present or it's null
                           (!('testGenConfig' in request.resource.data) || request.resource.data.testGenConfig == null) &&
                           request.resource.data.keys().hasOnly([
                             'userId', 'examId', 'courseId', 'questions', 'answers', 'markingResults', 'score', 'maxScore',
                             'status', 'createdAt', 'completedAt', 'durationMinutes', 'isTestGen',
                             'examType' // e.g., 'weekly', 'midterm', 'final', 'practice' - you might have this
                           ]) // Adjust this list based on your existing regular exam structure
                         ) ||
                         ( request.resource.data.isTestGen == true &&
                           request.resource.data.testGenConfig is map &&
                           isValidTestGenConfig(request.resource.data.testGenConfig) &&
                           // Ensure total questions from testGenConfig adds up to at least 10.
                           // This is complex for rules. Assume client/CF validated.
                           // We can check questions list size matches config.
                           // request.resource.data.questions.size() >= 10 && (complex sum here)
                           request.resource.data.keys().hasOnly([
                             'userId', 'examId', 'courseId', 'questions', 'answers', 'markingResults', 'score', 'maxScore',
                             'status', 'createdAt', 'completedAt', 'durationMinutes', 'isTestGen',
                             'testGenConfig'
                           ])
                         )
                       );

      // Generally, exams are immutable once created or only status/score/markingResults can be updated (e.g., by a grading function)
      // For simplicity, let's stick to no updates after creation for now, as per original rule.
      // If you need updates (e.g., 'started' -> 'completed'), this needs to be more granular.
      allow update: if false; // Or allow specific updates if needed, e.g., by an admin/grading function
                        // if (isAdmin() || request.auth.uid == resource.data.userId) &&
                        //    request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'completedAt', 'answers', 'score', 'markingResults']) &&
                        //    request.resource.data.status == 'completed' &&
                        //    request.resource.data.completedAt == request.time &&
                        //    resource.data.status == 'started'; // Example update logic

      allow delete: if isLoggedIn() && isOwner(userId);
    }

    // --- Usernames Registry ---
    match /usernames/{usernameDocId} {
      allow read: if true;
      allow create: if isLoggedIn() &&
                       request.resource.data.userId is string &&
                       request.resource.data.keys().hasOnly(['userId', 'username']) &&
                       request.resource.data.username.lower() == usernameDocId &&
                       ( (request.resource.data.userId == request.auth.uid) ||
                         isPrimaryAdmin()
                       );
      allow update: if false;
      allow delete: if isPrimaryAdmin();
    }

    // --- Users Collection ---
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if isLoggedIn() && request.auth.uid == userId &&
                      request.resource.data.email == request.auth.token.email &&
                      isValidString(request.resource.data.username, 3, 20) &&
                      isValidString(request.resource.data.displayName, 1, 50) &&
                      (request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.onboardingComplete == false &&
                      request.resource.data.isAdmin == isPrimaryAdminUid(userId) &&
                      request.resource.data.credits is number && request.resource.data.credits == 0 &&
                      request.resource.data.appData is map &&
                      request.resource.data.appData.subjects is map &&
                      request.resource.data.userNotes is map &&
                      request.resource.data.userAiChatSettings is map &&
                      isValidString(request.resource.data.userAiChatSettings.primaryModel, 1, 100) &&
                      isValidString(request.resource.data.userAiChatSettings.fallbackModel, 1, 100) &&
                      request.resource.data.userAiChatSettings.customSystemPrompts is map &&
                      request.resource.data.completedCourseBadges is list &&
                      request.resource.data.keys().hasAll([
                        'email', 'username', 'displayName', 'photoURL', 'createdAt',
                        'onboardingComplete', 'isAdmin', 'credits', 'appData', 'userNotes',
                        'userAiChatSettings', 'completedCourseBadges'
                      ]) && request.resource.data.keys().size() == 12;

      allow delete: if isOwner(userId) || isPrimaryAdmin();
      allow update: if isLoggedIn() && (
                       ( isOwner(userId) &&
                         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAdmin', 'credits', 'email', 'createdAt', 'username']) &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedUserUpdateFieldsOwner()) &&
                         isValidString(request.resource.data.displayName, 1, 50) &&
                         (request.resource.data.photoURL == null || request.resource.data.photoURL is string) &&
                         (request.resource.data.appData == null || request.resource.data.appData is map) &&
                         (request.resource.data.userNotes == null || request.resource.data.userNotes is map) &&
                         (request.resource.data.userAiChatSettings == null || (
                            request.resource.data.userAiChatSettings is map &&
                            isValidString(request.resource.data.userAiChatSettings.primaryModel, 1, 100) &&
                            isValidString(request.resource.data.userAiChatSettings.fallbackModel, 1, 100) &&
                            request.resource.data.userAiChatSettings.customSystemPrompts is map
                         ))
                       ) ||
                       ( isAdmin() && userId != request.auth.uid &&
                         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'createdAt']) &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedAdminUpdateFieldsOnOtherUser()) &&
                         (request.resource.data.displayName == null || isValidString(request.resource.data.displayName, 1, 50)) &&
                         (request.resource.data.username == null || isValidString(request.resource.data.username, 3, 20)) &&
                         (request.resource.data.isAdmin == null || request.resource.data.isAdmin is bool) &&
                         (request.resource.data.credits == null || (request.resource.data.credits is number && request.resource.data.credits >= 0)) &&
                         (request.resource.data.appData == null || request.resource.data.appData is map)
                       ) ||
                       ( isAdmin() && userId == request.auth.uid &&
                         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAdmin', 'email', 'createdAt', 'username']) &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedAdminUpdateFieldsOnSelf()) &&
                         (request.resource.data.credits == null || (request.resource.data.credits is number && request.resource.data.credits >= 0))
                       )
                     );

      match /inbox/{messageId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create: if (isAdmin() && request.resource.data.senderId == request.auth.uid) || request.resource.data.senderId == 'system';
        allow update: if isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) && request.resource.data.isRead == true;
        allow delete: if isOwner(userId) || isAdmin();
      }
      match /userFormulaSheets/{sheetId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create, update: if isOwner(userId) && isValidString(request.resource.data.content, 0, 100000) && request.resource.data.lastUpdated == request.time;
        allow delete: if isOwner(userId) || isAdmin();
      }
      match /userChapterSummaries/{summaryId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create, update: if isOwner(userId) && isValidString(request.resource.data.content, 0, 100000) && request.resource.data.lastUpdated == request.time;
        allow delete: if isOwner(userId) || isAdmin();
      }
      match /creditLog/{logId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create: if isLoggedIn() &&
                         request.resource.data.timestamp == request.time &&
                         request.resource.data.change is number &&
                         request.resource.data.newBalance is number &&
                         isValidString(request.resource.data.reason, 1, 200) &&
                         request.resource.data.performedBy is string &&
                         request.resource.data.keys().hasOnly(['timestamp', 'change', 'newBalance', 'reason', 'performedBy']) &&
                         ( (request.resource.data.performedBy == request.auth.uid && request.auth.uid == userId) ||
                           (request.resource.data.performedBy == 'system') ||
                           (isAdmin() && request.resource.data.performedBy == request.auth.uid)
                         );
        allow update, delete: if false;
      }
      match /aiChatSessions/{sessionId} {
        allow read, delete: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         isValidString(request.resource.data.name, 1, 100) &&
                         request.resource.data.history is list &&
                         request.resource.data.createdAt == request.time &&
                         request.resource.data.lastModified == request.time &&
                         isValidString(request.resource.data.systemPromptKey, 1, 100) &&
                         request.resource.data.keys().hasOnly(['name', 'history', 'createdAt', 'lastModified', 'systemPromptKey']);
        allow update: if isOwner(userId) &&
                         request.resource.data.history is list &&
                         request.resource.data.lastModified == request.time &&
                         request.resource.data.createdAt == resource.data.createdAt &&
                         request.resource.data.name == resource.data.name &&
                         request.resource.data.systemPromptKey == resource.data.systemPromptKey &&
                         request.resource.data.keys().hasOnly(['name', 'history', 'createdAt', 'lastModified', 'systemPromptKey']);
      }
    }

    match /userCourseProgress/{userId}/courses/{courseId} {
      allow read: if isLoggedIn() && (isOwner(userId) || isAdmin());
      allow create: if isLoggedIn() && isOwner(userId) &&
               request.resource.data.courseId == courseId &&
               request.resource.data.status == 'enrolled' &&
               request.resource.data.enrollmentMode is string &&
                 (request.resource.data.enrollmentMode == 'full' || request.resource.data.enrollmentMode == 'viewer') &&
               request.resource.data.selectedPace is string &&
               (request.resource.data.customPaceDays == null || (request.resource.data.customPaceDays is number && request.resource.data.customPaceDays >= 7)) &&
               request.resource.data.baseMediocrePace == null &&
               request.resource.data.currentPace == null &&
               request.resource.data.currentChapterTarget == 1 &&
               request.resource.data.currentDayObjective is string &&
               request.resource.data.courseStudiedChapters is list && request.resource.data.courseStudiedChapters.size() == 0 &&
               request.resource.data.dailyProgress is map && request.resource.data.dailyProgress.size() == 0 &&
               request.resource.data.watchedVideoUrls is map && request.resource.data.watchedVideoUrls.size() == 0 &&
               request.resource.data.watchedVideoDurations is map && request.resource.data.watchedVideoDurations.size() == 0 &&
               request.resource.data.pdfProgress is map && request.resource.data.pdfProgress.size() == 0 &&
               request.resource.data.skipExamAttempts is map && request.resource.data.skipExamAttempts.size() == 0 &&
               request.resource.data.lastSkipExamScore is map && request.resource.data.lastSkipExamScore.size() == 0 &&
               request.resource.data.assignmentScores is map && request.resource.data.assignmentScores.size() == 0 &&
               request.resource.data.weeklyExamScores is map && request.resource.data.weeklyExamScores.size() == 0 &&
               request.resource.data.midcourseExamScores is map && request.resource.data.midcourseExamScores.size() == 0 &&
               request.resource.data.finalExamScores == null &&
               request.resource.data.attendanceScore == 100 &&
               request.resource.data.extraPracticeBonus == 0 &&
               request.resource.data.testGenBonus == 0 &&
               request.resource.data.totalMark == null &&
               request.resource.data.grade == null &&
               request.resource.data.completionDate == null &&
               // Allow enrollmentDate and lastActivityDate if they are server timestamps
               request.resource.data.enrollmentDate == request.time &&
               request.resource.data.lastActivityDate == request.time &&
               // Update the hasOnly list to include these two fields
               request.resource.data.keys().hasOnly([
                 'courseId', 'status', 'enrollmentMode',
                 'selectedPace', 'customPaceDays', 'baseMediocrePace', 'currentPace',
                 'currentChapterTarget', 'currentDayObjective',
                 'courseStudiedChapters', 'dailyProgress',
                 'watchedVideoUrls', 'watchedVideoDurations', 'pdfProgress',
                 'skipExamAttempts', 'lastSkipExamScore',
                 'assignmentScores', 'weeklyExamScores', 'midcourseExamScores', 'finalExamScores',
                 'attendanceScore', 'extraPracticeBonus', 'testGenBonus',
                 'totalMark', 'grade', 'completionDate',
                 'enrollmentDate', 'lastActivityDate' // Add them here
               ]);
      allow update: if isLoggedIn() && (
                      ( isOwner(userId) &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedCourseProgressUpdateFieldsOwner()) &&
                        request.resource.data.courseId == resource.data.courseId &&
                        request.resource.data.enrollmentDate == resource.data.enrollmentDate
                      ) ||
                      ( isAdmin() &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedCourseProgressUpdateFieldsAdmin()) &&
                        request.resource.data.courseId == resource.data.courseId &&
                        (request.resource.data.enrollmentDate == resource.data.enrollmentDate || request.resource.data.enrollmentDate is timestamp) &&
                        (request.resource.data.totalMark == null || request.resource.data.totalMark is number) &&
                        (request.resource.data.completionDate == null || request.resource.data.completionDate is timestamp)
                      )
                    );
      allow delete: if isLoggedIn() && (isOwner(userId) || isPrimaryAdmin());
    }

    match /userExams/{userId}/exams/{examId} {
      allow read: if isLoggedIn() && (isOwner(userId) || isAdmin());
      allow create: if isLoggedIn() && isOwner(userId) &&
                       request.resource.data.userId == userId &&
                       request.resource.data.examId == examId &&
                       request.resource.data.questions is list &&
                       request.resource.data.markingResults is map &&
                       request.resource.data.status == 'completed' &&
                       request.resource.data.timestamp is number;
      allow update: if false;
      allow delete: if isLoggedIn() && isOwner(userId);
    }

    match /feedback/{feedbackId} {
      allow create: if isLoggedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.timestamp == request.time &&
                       isValidString(request.resource.data.feedbackText, 1, 5000);
      allow read, update, delete: if isAdmin();
    }
    match /examIssues/{issueId} {
      allow create: if isLoggedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.timestamp == request.time &&
                       isValidString(request.resource.data.feedbackText, 1, 5000);
      allow read, update, delete: if isAdmin();
    }

    match /courses/{courseId} {
      allow read: if true;
      allow create: if isLoggedIn() &&
                       request.resource.data.creatorUid == request.auth.uid &&
                       ( ( request.resource.data.status == 'pending' && !isAdmin() ) ||
                         ( (request.resource.data.status == 'approved' || request.resource.data.status == 'pending') && isAdmin() )
                       ) &&
                       isValidString(request.resource.data.name, 1, 150) &&
                       request.resource.data.createdAt == request.time &&
                       isValidString(request.resource.data.creatorName, 1, 50) &&
                       isValidString(request.resource.data.courseDirName, 1, 100) &&
                       request.resource.data.totalChapters is number && request.resource.data.totalChapters >=0 &&
                       request.resource.data.chapters is list &&
                       (request.resource.data.relatedSubjectId == null || request.resource.data.relatedSubjectId is string) &&
                       request.resource.data.prerequisites is list &&
                       request.resource.data.corequisites is list &&
                       request.resource.data.youtubePlaylistUrls is list &&
                       (request.resource.data.imageUrl == null || request.resource.data.imageUrl is string) &&
                       (request.resource.data.coverUrl == null || request.resource.data.coverUrl is string) &&
                       request.resource.data.chapterResources is map;
      allow update: if isAdmin();
      allow delete: if isAdmin() && courseId != "fop_physics_v1";
    }

    match /sharedCourseNotes/{noteId} {
      allow read: if isLoggedIn();
      allow create: if isLoggedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isLoggedIn() && (resource.data.userId == request.auth.uid || isAdmin());
    }

    match /adminTasks/{taskId} {
      allow read, create, update, delete: if isPrimaryAdmin();
    }
    match /taskVersions/{versionId} {
      allow read, write: if isPrimaryAdmin();
      match /tasks/{taskId} {
         allow read, write: if isPrimaryAdmin();
      }
    }

    match /globalChatMessages/{messageId} {
      allow read: if isLoggedIn();
      allow create: if isLoggedIn() &&
                       request.resource.data.senderId == request.auth.uid &&
                       isValidString(request.resource.data.text, 1, 1000) &&
                       request.resource.data.timestamp == request.time &&
                       request.resource.data.isPinned == false &&
                       request.resource.data.mentions is list;
      allow update: if isAdmin() &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isPinned']) &&
                       request.resource.data.isPinned is bool;
      allow delete: if isLoggedIn() && (resource.data.senderId == request.auth.uid || isAdmin());
    }

    match /settings/{settingDocId} {
      allow read: if isLoggedIn();
      allow write: if isAdmin() && settingDocId == 'courseExamDefaults';
    }

    match /globalFormulaSheets/{sheetId} {
      allow read: if true;
      allow write: if isPrimaryAdmin();
    }
    match /globalChapterSummaries/{summaryId} {
      allow read: if true;
      allow write: if isPrimaryAdmin();
    }

    match /subjects/{subjectId} {
      allow read: if isLoggedIn();
      allow write: if isAdmin();
      // You can uncomment and complete the more specific rules below if needed
      // allow create, update: if isAdmin() &&
      //                     request.resource.data.name is string && request.resource.data.name.size() > 0 &&
      //                     request.resource.data.fileName is string && request.resource.data.fileName.size() > 0 &&
      //                     request.resource.data.chapters is map &&
      //                     request.resource.data.mcqProblemRatio is number && request.resource.data.mcqProblemRatio >= 0 && request.resource.data.mcqProblemRatio <= 1 &&
      //                     request.resource.data.defaultTestDurationMinutes is number && request.resource.data.defaultTestDurationMinutes >= 5 &&
      //                     request.resource.data.max_questions_per_test is number && request.resource.data.max_questions_per_test >= 1 &&
      //                     request.resource.data.status == 'approved' &&
      //                     request.resource.data.creatorUid == request.auth.uid &&
      //                     request.resource.data.createdAt == request.time;
    } // <<<< THIS IS THE CORRECTED CLOSING BRACE FOR /subjects/{subjectId}

  } // End /databases/{database}/documents
}